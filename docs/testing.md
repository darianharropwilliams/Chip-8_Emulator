# Testing Philosophy: CHIP-8 Emulator

This document explains the **philosophy**, **design goals**, and **structure** of the CHIP-8 emulator test suite, which focuses on high-confidence verification of opcode execution, control flow, memory behavior, and emulator correctness.

---

## Philosophy

The testing framework is built around **ROM-driven integration tests** that execute real CHIP-8 bytecode. This mirrors how actual games interact with the emulator, giving us high coverage with minimal boilerplate.

Rather than mocking internals or testing functions in isolation, the approach is:

> **“Write small ROMs that produce a predictable hardware state, and verify the state afterward.”**

This reflects a philosophy rooted in **black-box testing**: we treat the emulator like a physical machine, interact with it using programs, and observe outputs.

---

## Test Design

### Deterministic Execution

Each ROM:
- Executes a minimal, purpose-built program
- Ends with a `RET` to signal completion
- Causes the emulator (in `--test` mode) to dump full memory and register state to a `.bin` file

Python scripts then:
- Load the dump
- Assert expected state: register values, memory contents, timers

This design ensures **repeatable, deterministic tests** — with no need for hooks or special emulation flags.

---

### What Is Tested?

The test suite checks:
- Register assignments (e.g. `Vx = value`)
- Arithmetic and logic (e.g. `ADD Vx, Vy`)
- Memory operations (`LD [I], Vx`)
- Control flow (`JP`, `CALL`, `RET`)
- BCD conversion
- Key input skipping
- Sprite drawing (via framebuffer state if needed)

---

###  Timer Handling Philosophy

Timers (`delay_timer`, `sound_timer`) decrement at **60Hz**, independent of opcode timing.

Because the test harness runs at frame-based intervals and cannot perfectly simulate real-time hardware, timer values vary by 1–2 ticks depending on runtime speed and OS scheduler behavior.

> **Result: Timer tests are excluded from automated assertions.**

Instead:
- The relevant ROMs (e.g. `timer_set.rom`) still execute
- The final dump includes timer values
- You can inspect them manually if needed

This acknowledges **real-world timing constraints** without undermining confidence in emulator correctness.

---

## Test Architecture Overview

```
tests/
├── C/                  # C test harness (e.g. state dumping via chip8_testshim.c)
├── python/             # Test driver and utilities
│   ├── generate_test_roms.py   # Auto-generates ROM files for coverage
│   ├── test_chip8.py           # Runs tests and validates dumps
│   ├── helpers.py              # Binary parser for dumps
│   ├── fixtures/               # Generated .rom programs (input)
│   └── dumps/                  # Generated .bin snapshots (output)
```

---

## Running the Tests

From the root directory, ensure you're rebuilt and then run:

```bash
python tests/python/test_chip8.py
```

To test a specific ROM:

```bash
python tests/python/test_chip8.py ld_vx
```

To regenerate test ROMs (if fixtures are missing or outdated):

```bash
python tests/python/generate_test_roms.py
```

---

## Key Advantages

- **Minimal setup**: All ROMs are self-contained and autogenerated
- **True-to-hardware behavior**: Runs real bytecode, just like games
- **Modular and extensible**: Add new test ROMs as needed
- **Cross-platform**: Works identically on native or WASM builds

---

## Summary

This test framework is designed to provide **confidence without friction**. It runs fast, integrates easily with CI or development, and represents a real-world stress test on your emulator.

> When the tests pass, you can trust your opcodes.
